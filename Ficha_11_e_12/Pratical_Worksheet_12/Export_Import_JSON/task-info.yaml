type: edu
files:
- name: test/Tests.java
  visible: false
  text: |-
    import org.junit.Assert;
    import org.junit.Test;
    import player.File;
    import player.IFile;
    import player.PPlayer;
    import player.comparators.AscendingDurationComparator;
    import player.comparators.AscendingNameComparator;
    import player.comparators.DescendingFilesizeComparator;
    import player.exceptions.InvalidFileException;
    import player.exceptions.InvalidPlayerStateException;

    import java.io.IOException;

    public class Tests {
        @Test
        public void testSolutionFile1() {
            File f1 = new File("Legendary Tiger Man - Big Black Boat", "mp3", 3072, 5);

            Assert.assertEquals("Name is not set properly", "Legendary Tiger Man - Big Black Boat", f1.getName());
            Assert.assertEquals("Extension is not set properly", "mp3", f1.getExtension());
            Assert.assertEquals("Duration is not set properly", 5, f1.getDurationSecs());
            Assert.assertEquals("Size is not set properly", 3072, f1.getSizeKB());
            Assert.assertTrue("toString is not including file name", f1.toString().contains(f1.getName()));
            Assert.assertTrue("toString is not including file extension", f1.toString().contains(f1.getExtension()));
            Assert.assertTrue("toString is not including file duration", f1.toString().contains(String.valueOf(f1.getDurationSecs())));
            Assert.assertTrue("toString is not including file size", f1.toString().contains(String.valueOf(f1.getSizeKB())));


        }

        @Test
        public void testSolutionFile2() {
            File f1 = new File("Legendary Tiger Man - Big Black Boat", "mp4", 5120, 15);

            Assert.assertEquals("Name is not set properly", "Legendary Tiger Man - Big Black Boat", f1.getName());
            Assert.assertEquals("Extension is not set properly", "mp4", f1.getExtension());
            Assert.assertEquals("Duration is not set properly", 15, f1.getDurationSecs());
            Assert.assertEquals("Size is not set properly", 5120, f1.getSizeKB());
            Assert.assertTrue("toString is not including file name", f1.toString().contains(f1.getName()));
            Assert.assertTrue("toString is not including file extension", f1.toString().contains(f1.getExtension()));
            Assert.assertTrue("toString is not including file duration", f1.toString().contains(String.valueOf(f1.getDurationSecs())));
            Assert.assertTrue("toString is not including file size", f1.toString().contains(String.valueOf(f1.getSizeKB())));

        }

        @Test
        public void testSolutionEqualsTrue() {
            File f1 = new File("Legendary Tiger Man - Big Black Boat", "mp3", 3072, 5);
            File f2 = new File("Legendary Tiger Man - Big Black Boat", "mp3", 3072, 5);
            Assert.assertEquals("Comparison between two files with all equal attributes must return true", f1, f2);
            Assert.assertEquals("Comparing with the same object must return true", f1, f1);
            Assert.assertEquals("Comparing with the same object must return true", f2, f2);
        }

        @Test
        public void testSolutionEqualsFalse() {
            File f1 = new File("Legendary Tiger Man - Big Black Boat", "mp3", 3072, 5);
            File f2 = new File("Legendary Tiger Man - Big Black Boat", "mp4", 5120, 15);
            Assert.assertNotEquals("Comparison between two files with different attributes must return false", f1, f2);
            Assert.assertNotEquals("Comparing with null must return false", null, f1);
            Assert.assertNotEquals("Comparing with different type of object must return false", f1, new Object());
        }

        @Test
        public void addFileNull() {

            PPlayer pp = new PPlayer();
            try {
                pp.addFile(null);
            } catch (InvalidPlayerStateException e) {
                Assert.fail("Adding a null file should create a InvalidFileException");
            } catch (InvalidFileException ignored) {

            }

        }

        @Test
        public void addFileOverMemoryLimit() {
            PPlayer pp = new PPlayer();
            try {
                pp.addFile(new File("Legendary Tiger Man - Big Black Boat", "mp3", 200000, 5));
            } catch (InvalidPlayerStateException ignored) {

            } catch (InvalidFileException e) {
                Assert.fail("Surpassing the available memory should return InvalidPlayerStateException");
            }
        }

        @Test
        public void addFileOverPlayerCapacity() {
            PPlayer pp = new PPlayer();
            try {
                for (int i = 0; i < 21; i++) pp.addFile(new File("Legendary Tiger Man - Big Black Boat", "mp3", 1024, 30));
            } catch (InvalidPlayerStateException ignored) {

            } catch (InvalidFileException e) {
                Assert.fail("Adding more than 20 files should return InvalidPlayerStateException");
            }

        }

        @Test
        public void addFilePlayFileDeleteFile() {
            File f = new File("Legendary Tiger Man - Big Black Boat", "mp3", 1024, 1);
            PPlayer pp = new PPlayer();
            try {
                pp.addFile(f);
                pp.playTrack(0);
                IFile resp = pp.deleteFile(0);
                Assert.assertEquals("Removing an element is not working properly", f, resp);
            } catch (InvalidPlayerStateException | InvalidFileException e) {
                Assert.fail("Throwing exception when adding and removing file correctly");
            }

        }

        @Test
        public void addFilePlayFiles() {
            File f = new File("Legendary Tiger Man - Big Black Boat", "mp3", 1024, 1);
            File f1 = new File("Legendary Tiger Man - Big Black Boat2", "mp3", 1024, 1);
            File f2 = new File("Legendary Tiger Man - Big Black Boat", "mp3", 1024, 1);
            File f3 = new File("Legendary Tiger Man - Big Black Boat", "mp3", 1024, 1);
            PPlayer pp = new PPlayer();
            try {
                pp.addFile(f);
                pp.addFile(f1);
                pp.addFile(f2);
                pp.addFile(f3);
                pp.playTrack(0);
                Assert.assertTrue(true);
                IFile resp = pp.deleteFile(0);
                Assert.assertEquals("Removing an element is not working properly", f, resp);
            } catch (InvalidPlayerStateException | InvalidFileException e) {
                Assert.fail("Throwing exception when adding and removing file correctly");
            }

        }

        @Test
        public void addFilePlayFiles2() {
            File f = new File("Legendary Tiger Man - Big Black Boat", "mp3", 1024, 1);
            File f1 = new File("Legendary Tiger Man - Big Black Boat2", "mp3", 1024, 1);
            File f2 = new File("Legendary Tiger Man - Big Black Boat", "mp3", 1024, 1);
            File f3 = new File("Legendary Tiger Man - Big Black Boat", "mp3", 1024, 1);
            PPlayer pp = new PPlayer();
            try {
                pp.addFile(f);
                pp.addFile(f1);
                pp.addFile(f2);
                pp.addFile(f3);
                pp.playTrack(0);
                int i = 1;
                while (i < 5) {
                    int nextTrack = pp.nextTrack();
                    if (i == 4) {
                        Assert.assertEquals("When there is no next track the return value must be 0", 0, nextTrack);
                    } else {
                        Assert.assertEquals("Next track from " + (i - 1) + " should be " + i, i, nextTrack);
                    }
                    i++;
                }

                i = 2;
                pp.playTrack(3);
                while (i >= 0) {
                    int previousTrack = pp.previousTrack();
                    if (i == 0) {
                        Assert.assertEquals("When there is no previous track the return must be 0", 0, previousTrack);
                    } else {
                        Assert.assertEquals("Previous track from " + (i + 1) + " should be " + i, i, previousTrack);
                    }
                    i--;
                }
            } catch (InvalidPlayerStateException | InvalidFileException e) {
                Assert.fail("Throwing exception when adding and removing file correctly");
            }

        }

        @Test
        public void addPlayFileInvalid() {
            PPlayer pp = new PPlayer();
            try {
                pp.addFile(new File("Legendary Tiger Man - Big Black Boat", "mp3", 200, -5));
            } catch (InvalidPlayerStateException e) {
                Assert.fail("Adding a file with negative duration must throw InvalidPlayerStateException");
            } catch (InvalidFileException ignored) {

            }

        }

        @Test
        public void addFileSizeInvalid() {
            PPlayer pp = new PPlayer();
            try {
                pp.addFile(new File("Legendary Tiger Man - Big Black Boat", "mp3", -2, 5));
            } catch (InvalidPlayerStateException e) {
                Assert.fail("Adding a file with negative size must throw InvalidPlayerStateException");
            } catch (InvalidFileException ignored) {

            }
        }

        @Test
        public void listFiles() {
            PPlayer pp = new PPlayer();
            try {
                pp.addFile(new File("Legendary Tiger Man - Big Black Boat1", "mp4", 20, 1));
            } catch (InvalidPlayerStateException | InvalidFileException ignored) {

            }
            try {
                pp.addFile(new File("Legendary Tiger Man - Big Black Boat2", "mp3", 20, 1));
            } catch (InvalidPlayerStateException | InvalidFileException ignored) {
            }
            String value = pp.list();
            Assert.assertTrue("List all files is not considering all valid files", value.contains("Legendary Tiger Man - Big Black Boat2"));
            Assert.assertFalse("List all files is including an invalid file", value.contains("Legendary Tiger Man - Big Black Boat1"));
        }

        @Test
        public void globalFailures() {
            Assert.assertEquals("Not all failures are considered as global failures", 3, PPlayer.globalFailures);
        }

        @Test
        public void shuffleNameAscending() {
            File f1 = new File("B", "mp3", 2, 1);
            File f2 = new File("AA", "mp3", 2, 1);
            File f3 = new File("A", "mp3", 2, 1);
            PPlayer p = new PPlayer(new AscendingNameComparator());
            try {
                p.addFile(f1);

                p.addFile(f2);
                p.addFile(f3);

                p.shufflePlay();
            } catch (NullPointerException e) {
                Assert.fail("Null pointer in AscendingNameComparator");
            } catch (ArrayIndexOutOfBoundsException e) {
                Assert.fail("Out of bounds in AscendingNameComparator");
            } catch (InvalidPlayerStateException | InvalidFileException e) {
                Assert.fail("Error when adding valid file");
            }
            Assert.assertEquals("Shuffle Ascending Name is not working properly", p.deleteFile(2), f1);
            Assert.assertEquals("Shuffle Ascending Name is not working properly", p.deleteFile(1), f2);
            Assert.assertEquals("Shuffle Ascending Name is not working properly", p.deleteFile(0), f3);
        }

        @Test
        public void shuffleDurationAscending() {
            File f1 = new File("B", "mp3", 2, 100);
            File f2 = new File("AA", "mp3", 2, 10);
            File f3 = new File("A", "mp3", 2, 1);
            PPlayer p = new PPlayer(new AscendingDurationComparator());

            try {
                p.addFile(f1);
                p.addFile(f2);
                p.addFile(f3);
                p.shufflePlay();
            } catch (NullPointerException e) {
                Assert.fail("Null pointer in AscendingNameComparator");
            } catch (ArrayIndexOutOfBoundsException e) {
                Assert.fail("Out of bounds in AscendingNameComparator");
            } catch (InvalidPlayerStateException | InvalidFileException e) {
                Assert.fail("Error when adding valid file");
            }
            System.out.println(p.list());
            Assert.assertEquals("Shuffle Duration Ascending is not working properly", p.deleteFile(2), f1);
            Assert.assertEquals("Shuffle Duration Ascending is not working properly", p.deleteFile(1), f2);
            Assert.assertEquals("Shuffle Duration Ascending is not working properly", p.deleteFile(0), f3);
        }

        @Test
        public void shuffleFileSizeDescending() {
            File f1 = new File("B", "mp3", 10, 100);
            File f2 = new File("AA", "mp3", 20, 10);
            File f3 = new File("A", "mp3", 2, 1);
            PPlayer p = new PPlayer(new DescendingFilesizeComparator());

            try {
                p.addFile(f1);
                p.addFile(f2);
                p.addFile(f3);
                p.shufflePlay();
            } catch (NullPointerException e) {
                Assert.fail("Null pointer in AscendingNameComparator");
            } catch (ArrayIndexOutOfBoundsException e) {
                Assert.fail("Out of bounds in AscendingNameComparator");
            } catch (InvalidPlayerStateException | InvalidFileException e) {
                Assert.fail("Error when adding valid file");
            }

            System.out.println(p.list());

            Assert.assertEquals("Shuffle File Size Descending is not working properly", p.deleteFile(2), f3);
            Assert.assertEquals("Shuffle File Size Descending is not working properly", p.deleteFile(1), f1);
            Assert.assertEquals("Shuffle File Size Descending is not working properly", p.deleteFile(0), f2);
        }


        @Test
        public void testSerializeBackup() {
            PPlayer p = new PPlayer();
            File f1 = new File("B", "mp3", 10, 100);
            File f2 = new File("AA", "mp3", 20, 10);
            File f3 = new File("A", "mp3", 2, 1);
            try {
                p.addFile(f1);
                p.addFile(f2);
                p.addFile(f3);
                p.backup("temp.bak");
            } catch (InvalidPlayerStateException | InvalidFileException | IOException e) {
                Assert.fail("Generating exception when backup file correctly");
            }

            java.io.File tmp = new java.io.File("temp.bak");
            Assert.assertTrue("File was not created during backup", tmp.exists());
        }

        @Test
        public void testSerializeRestore() {
            PPlayer p = new PPlayer();
            File f1 = new File("B", "mp3", 10, 100);
            File f2 = new File("AA", "mp3", 20, 10);
            File f3 = new File("A", "mp3", 2, 1);
            try {
                p.addFile(f1);
                p.addFile(f2);
                p.addFile(f3);
                p.backup("temp.bak");
            } catch (InvalidPlayerStateException | InvalidFileException | IOException e) {
                Assert.fail("Generating exception when backup file correctly");
            }
            java.io.File tmp = new java.io.File("temp.bak");
            Assert.assertTrue(tmp.exists());
            try {
                p.recover("temp.bak");
            } catch (IOException | ClassNotFoundException e) {
                Assert.fail("Generating exception when recover file correctly");
            }
        }

        @Test
        public void testSerializeAll() {
            PPlayer p = new PPlayer();
            File f1 = new File("B", "mp3", 10, 100);
            File f2 = new File("AA", "mp3", 20, 10);
            File f3 = new File("A", "mp3", 2, 1);
            try {
                p.addFile(f1);
                p.addFile(f2);
                p.addFile(f3);
                p.backup("temp.bak");
            } catch (InvalidPlayerStateException | IOException | InvalidFileException e) {
                Assert.fail("Generating exception when backup file correctly");
            }

            java.io.File tmp = new java.io.File("temp.bak");
            Assert.assertTrue(tmp.exists());
            PPlayer pp = new PPlayer();
            try {
                pp.recover("temp.bak");
            } catch (IOException | ClassNotFoundException e) {
                Assert.fail("Generating exception when recover file correctly");
            }
            int i = 0;
            while (i < 3) {
                try {
                    Assert.assertEquals(p.deleteFile(0), pp.deleteFile(0));
                } catch (ArrayIndexOutOfBoundsException ex) {
                    Assert.fail("Reading the file is not working properly.");
                }
                i++;
            }
        }

        @Test
        public void testJSONBackup() {
            PPlayer p = new PPlayer();
            File f1 = new File("B", "mp3", 10, 100);
            File f2 = new File("AA", "mp3", 20, 10);
            File f3 = new File("A", "mp3", 2, 1);
            try {
                p.addFile(f1);
                p.addFile(f2);
                p.addFile(f3);
                p.backupJSON("temp.bak");
            } catch (InvalidPlayerStateException | IOException | InvalidFileException e) {
                Assert.fail("Generating exception when backup JSON file correctly");
            }
            java.io.File tmp = new java.io.File("temp.bak");
            Assert.assertTrue(tmp.exists());
        }

        @Test
        public void testJSONRestore() {
            PPlayer p = new PPlayer();
            File f1 = new File("B", "mp3", 10, 100);
            File f2 = new File("AA", "mp3", 20, 10);
            File f3 = new File("A", "mp3", 2, 1);
            try {
                p.addFile(f1);
                p.addFile(f2);
                p.addFile(f3);
                p.backupJSON("temp.bak");
            } catch (InvalidPlayerStateException | IOException | InvalidFileException e) {
                Assert.fail("Generating exception when backup JSON file correctly");
            }
            java.io.File tmp = new java.io.File("temp.bak");
            Assert.assertTrue(tmp.exists());
            try {
                p.recoverJSON("temp.bak");
            } catch (IOException | ClassNotFoundException e) {
                Assert.fail("Generating exception when recover JSON file correctly");
            }
        }

        @Test
        public void testJSONAll() {
            PPlayer p = new PPlayer();
            File f1 = new File("B", "mp3", 10, 100);
            File f2 = new File("AA", "mp3", 20, 10);
            File f3 = new File("A", "mp3", 2, 1);
            try {
                p.addFile(f1);
                p.addFile(f2);
                p.addFile(f3);
                p.backupJSON("temp.bak");
            } catch (InvalidPlayerStateException | IOException | InvalidFileException e) {
                Assert.fail("Generating exception when backup JSON file correctly");
            }
            java.io.File tmp = new java.io.File("temp.bak");
            Assert.assertTrue(tmp.exists());
            PPlayer pp = new PPlayer();
            try {
                pp.recoverJSON("temp.bak");
            } catch (IOException | ClassNotFoundException e) {
                Assert.fail("Generating exception when recover JSON file correctly");
            }
            int i = 0;
            while (i < 3) {
                try {
                    Assert.assertEquals(p.deleteFile(0), pp.deleteFile(0));
                }catch(ArrayIndexOutOfBoundsException e){
                    Assert.fail("Reading the JSON file is not working properly.");
                }
                i++;
            }
        }
    }
  learner_created: false
- name: src/player/IFile.java
  visible: true
  text: |
    package player;

    public interface IFile {
        /**
         * Gets the attribute name
         *
         * @return The file name
         */
        public String getName();

        /**
         * Gets the attribute  extension
         *
         * @return The file extension
         */
        public String getExtension();

        /**
         * Gets the attribute sizeKB
         *
         * @return The size in KB
         */
        public int getSizeKB();

        /**
         * Gets the attribute  durationSecs
         *
         * @return The file duration in seconds
         */
        public int getDurationSecs();

        /**
         * Returns a string representation of the object. In general, the toString
         * method returns a string that "textually represents" this object. The
         * result should be a concise but informative representation that is easy
         * for a person to read
         *
         * @return A string representation of the object
         */
        @Override
        public String toString();

        /**
         * Indicates whether some other object is "equal to" this one, that is, if
         * the other object is an instance of <code>File</code> and all its asttributes
         * are the same as this object
         *
         * @param obj The reference object with which to compare
         * @return <code>true</code>if this object is "the same" as the
         * <code>obj</code>, <code>false</code> otherwise
         */
        @Override
        public boolean equals(Object obj);
    }
  learner_created: false
- name: src/player/comparators/AscendingDurationComparator.java
  visible: true
  placeholders:
  - offset: 212
    length: 9
    placeholder_text: type here
    dependency:
      lesson: Pratical_Worksheet_12
      task: Export_Import_Serializable
      file: src/player/comparators/AscendingDurationComparator.java
      placeholder: 1
      is_visible: false
    initial_state:
      length: 9
      offset: 212
    initialized_from_dependency: false
    possible_answer: "\n        if (o1 == null && o2 == null) {\n            return\
      \ 0;\n        } else if (o1 == null) {\n            return 1;\n        } else\
      \ if (o2 == null) {\n            return -1;\n        } else {\n            return\
      \ o1.getDurationSecs() - o2.getDurationSecs();\n        }\n\n   "
    selected: false
    status: Unchecked
  text: |
    package player.comparators;

    import player.IFile;

    import java.util.Comparator;

    public class AscendingDurationComparator implements Comparator<IFile> {
        @Override
        public int compare(IFile o1, IFile o2) {
    type here }
    }
  learner_created: false
- name: src/player/exceptions/InvalidFileException.java
  visible: true
  placeholders:
  - offset: 466
    length: 9
    placeholder_text: type here
    dependency:
      lesson: Pratical_Worksheet_12
      task: Export_Import_Serializable
      file: src/player/exceptions/InvalidFileException.java
      placeholder: 1
      is_visible: false
    initial_state:
      length: 9
      offset: 466
    initialized_from_dependency: false
    possible_answer: |2-
       /**
           * Constructs an instance of <code>InvalidFileException</code> with the
           * specified detail message.
           *
           * @param msg the detail message.
           */
          public InvalidFileException(String msg) {
              super("Unsupported file exception: " + msg);
          }
    selected: false
    status: Unchecked
  text: |-
    package player.exceptions;

    /**
     * <h1> This class implements the invalid file exception </h1>
     *
     * <h2>
     * ESTG - Escola Superior de Tecnologia e Gestão <br>
     * IPP - Instituto Politécnico do Porto <br>
     * PP - Paradigmas da Programação <br>
     * </h2>
     *
     * <h3>
     * LEI - Licenciatura em Engenharia Informática <br>
     * LSIRC - Licenciatura em Segurança Informática e Redes de Computadores <br>
     * </h3>
     */
    public class InvalidFileException extends Exception {

       type here
    }
  learner_created: false
- name: src/player/comparators/AscendingNameComparator.java
  visible: true
  placeholders:
  - offset: 211
    length: 9
    placeholder_text: type here
    dependency:
      lesson: Pratical_Worksheet_12
      task: Export_Import_Serializable
      file: src/player/comparators/AscendingNameComparator.java
      placeholder: 1
      is_visible: false
    initial_state:
      length: 9
      offset: 211
    initialized_from_dependency: false
    possible_answer: "\n        if (o1 == null && o2 == null) {\n            return\
      \ 0;\n        } else if (o1 == null) {\n            return 1;\n        } else\
      \ if (o2 == null) {\n            return -1;\n        } else {\n            return\
      \ o1.getName().compareTo(o2.getName());\n        }\n\n   "
    selected: false
    status: Unchecked
  text: |
    package player.comparators;


    import player.IFile;

    import java.util.Comparator;

    public class AscendingNameComparator implements Comparator<IFile> {

        @Override
        public int compare(IFile o1, IFile o2) {

    type here }
    }
  learner_created: false
- name: src/player/PPod.java
  visible: true
  text: |
    package player;

    import player.exceptions.InvalidFileException;
    import player.exceptions.InvalidPlayerStateException;

    public interface PPod {

        /**
         * Add a new <code>File</code> to the player
         *
         * @param file The {@link File file} to add
         * @throws InvalidFileException        Exception thrown when the {@link File file} is null or size is invalid
         * @throws InvalidPlayerStateException Exception thrown when the {@link File file} when the maximum number of files is achieved or memory is full
         */
        public void addFile(IFile file) throws InvalidFileException, InvalidPlayerStateException, InvalidPlayerStateException, InvalidFileException;

        /**
         * Deletes a {@link File file} given its position in the player list
         *
         * @param index the index of the {@link File file}
         * @return The deleted {@link File file}
         * @throws ArrayIndexOutOfBoundsException Exception thrown when index is not valid
         */
        public IFile deleteFile(int index) throws ArrayIndexOutOfBoundsException;

        /**
         * Play a given track given its index
         *
         * @param index the position of the {@link File file} in the track list
         * @throws ArrayIndexOutOfBoundsException Exception thrown when index is not valid
         * @throws InvalidFileException           Exception thrown when the file extension is not valid
         */
        public void playTrack(int index) throws ArrayIndexOutOfBoundsException, InvalidFileException;

        /**
         * Plays the next valid track
         *
         * @return the index of the next valid track
         */
        public int nextTrack();

        /**
         * Plays the valid previous track
         *
         * @return the index of the previous valid track
         */
        public int previousTrack();

        /**
         * Lists all valid files in the music player
         */
        public String list();

        /**
         * Reorders Files in the music player according to strategy defined in constructor
         */
        public void shufflePlay();

    }
  learner_created: false
- name: src/player/comparators/DescendingFilesizeComparator.java
  visible: true
  placeholders:
  - offset: 214
    length: 9
    placeholder_text: type here
    dependency:
      lesson: Pratical_Worksheet_12
      task: Export_Import_Serializable
      file: src/player/comparators/DescendingFilesizeComparator.java
      placeholder: 1
      is_visible: false
    initial_state:
      length: 9
      offset: 214
    initialized_from_dependency: false
    possible_answer: "\n        if (o1 == null && o2 == null) {\n            return\
      \ 0;\n        } else if (o1 == null) {\n            return 1;\n        } else\
      \ if (o2 == null) {\n            return -1;\n        } else {\n            return\
      \ o2.getSizeKB() - o1.getSizeKB();\n        }\n\n   "
    selected: false
    status: Unchecked
  text: |
    package player.comparators;


    import player.IFile;

    import java.util.Comparator;

    public class DescendingFilesizeComparator implements Comparator<IFile> {
        @Override
        public int compare(IFile o1, IFile o2) {
    type here }
    }
  learner_created: false
- name: src/player/PPlayer.java
  visible: true
  placeholders:
  - offset: 531
    length: 9
    placeholder_text: type here
    dependency:
      lesson: Pratical_Worksheet_12
      task: Export_Import_Serializable
      file: src/player/PPlayer.java
      placeholder: 1
      is_visible: false
    initial_state:
      length: 9
      offset: 531
    initialized_from_dependency: false
    possible_answer: |2-

          /**
           * Maximum memory capacity of {@link PPod PPod}
           */
          private static final int MEMORY_SIZE = 102400;

          /**
           * Maximum number of files
           */
          private static final int INDEX_SIZE = 20;
          /**
           * Valid file extension
           */
          private static final String EXTENSION = "mp3";

          /**
           * Comparator used for shuffling
           */
          private Comparator<IFile> comparatorStrategy;
          /**
           * Current track that is being played
           */
          private int currentTrack;

          /**
           * Collection to store the files
           */
          private IFile[] files;

          /**
           * Creates an instance of <code>PPlayer</code>
           */
          public PPlayer() {
              this.currentTrack = 0;
              this.files = new File[INDEX_SIZE];
              this.comparatorStrategy = new AscendingDurationComparator();
          }

          /**
           * Creates an instance of <code>PPlayer</code>
           */
          public PPlayer(Comparator<IFile> comp) {
              this.currentTrack = 0;
              this.files = new File[INDEX_SIZE];
              this.comparatorStrategy = comp;
          }


          /**
           * {@inheritDoc}
           */
          @Override
          public void addFile(IFile file) throws InvalidPlayerStateException, InvalidFileException {
              if (file == null) {
                  this.globalFailures++;
                  throw new InvalidFileException("file argument cannot be null");
              }

              if (file.getSizeKB() < 0) {
                  this.globalFailures++;
                  throw new InvalidFileException("file size is invalid");
              }

              if (isFileIndexFull()) {
                  this.globalFailures++;
                  throw new InvalidPlayerStateException("file index is full");
              }

              if (file.getSizeKB() + this.getUsedMemory() > PPlayer.MEMORY_SIZE) {
                  this.globalFailures++;
                  throw new InvalidPlayerStateException("memory is full");
              }

              int i = 0, size = this.files.length;
              boolean inserted = false;

              while (i < size && !inserted) {
                  if (this.files[i] == null) {
                      this.files[i] = file;
                      System.out.println("> ADD " + file.getName() + "." + file.getExtension() + " at index " + i);
                      inserted = true;
                  }
                  i++;
              }
          }

          /**
           * Check if all positions of the collection are occupied.
           *
           * @return <code>true</code>`` if collection is full, <code>false</code> otherwise
           */
          private boolean isFileIndexFull() {
              int i = 0, size = this.files.length;
              boolean full = true;
              while (i < size && full) {
                  if (this.files[i] == null) {
                      full = false;
                  }
                  i++;
              }
              return full;
          }

          /**
           * Calculate the used memory
           *
           * @return the size used to store all files (in KB)
           */
          private int getUsedMemory() {
              int usedMemory = 0, size = this.files.length;
              for (int i = 0; i < size; i++) {
                  if (this.files[i] != null) {
                      usedMemory += this.files[i].getSizeKB();
                  }
              }
              return usedMemory;
          }

          /**
           * {@inheritDoc}
           */
          @Override
          public IFile deleteFile(int index) throws ArrayIndexOutOfBoundsException {
              this.validateFileIndex(index);
              IFile toReturn = this.files[index];

              int size = this.files.length;
              for (int i = index; i < size - 1; i++) {
                  files[i] = files[i + 1];
              }
              files[size - 1] = null;

              System.out.println("> DELETE " + index);
              return toReturn;
          }

          /**
           * Auxiliary method to check if there is a file at a given position
           *
           * @param index position to check for a file
           * @throws ArrayIndexOutOfBoundsException Throws an exception if index is invalid or there isn't any file at that position
           */
          private void validateFileIndex(int index) throws ArrayIndexOutOfBoundsException {
              if (index < 0 || index >= INDEX_SIZE) {
                  throw new ArrayIndexOutOfBoundsException("file index must be between 0 and " + (INDEX_SIZE - 1));
              }
              if (this.files[index] == null) {
                  throw new ArrayIndexOutOfBoundsException("there is no file at index " + index);
              }
          }

          /**
           * Check if a valid is playable
           *
           * @param file the file to verify
           * @throws InvalidFileException Throws exception when file extension is not valid nor its duration
           */
          private void validateAudioFile(IFile file) throws InvalidFileException {
              if (!file.getExtension().equalsIgnoreCase(EXTENSION)) {
                  throw new InvalidFileException("file extension is invalid");
              }
          }

          /**
           * {@inheritDoc}
           */
          @Override
          public int nextTrack() {
              try {
                  this.currentTrack = lookForTrack(true);
                  System.out.println("> NEXT " + this.currentTrack);
              } catch (InvalidPlayerStateException ipse) {
                  System.out.println("Next track not found: " + ipse.getMessage());
                  this.currentTrack = 0;
              }
              return currentTrack;
          }

          /**
           * {@inheritDoc}
           */
          @Override
          public int previousTrack() {
              try {
                  this.currentTrack = lookForTrack(false);
                  System.out.println("> PREVIOUS " + this.currentTrack);
              } catch (InvalidPlayerStateException ipse) {
                  System.out.println("Previous track not found: " + ipse.getMessage());
                  this.currentTrack = 0;
              }
              return currentTrack;
          }

          /**
           * Look for the next (or previous) valid track
           *
           * @param forward if <code>true</code> check for the next valid track, previous otherwise
           * @return index of the next (or previous) valid track
           * @throws InvalidPlayerStateException throws exception when there isn't any following track
           */
          private int lookForTrack(boolean forward) throws InvalidPlayerStateException {
              int direction = forward ? 1 : -1;
              for (int i = this.currentTrack + direction; i >= 0 && i < this.files.length; i = i + direction) {
                  if (this.files[i] != null) {
                      try {
                          this.validateAudioFile(this.files[i]);
                          return i;
                      } catch (InvalidFileException ife) {
                          System.out.println("File at index " + i + " is not valid: " + ife.getMessage());
                      }
                  }
              }
              throw new InvalidPlayerStateException("reached " + (forward ? "end" : "beginning") + " of file index");
          }

          /**
           * {@inheritDoc}
           */
          public void playTrack(int index) throws InvalidFileException {
              this.validateFileIndex(index);
              this.validateAudioFile(this.files[index]);
              if (this.files[index].getDurationSecs() <= 0) {
                  throw new InvalidFileException("Invalide duration for file");
              }
              System.out.println("> PLAY " + (index < 10 ? "0" : "") + index + " " + this.files[index].getName());
              for (int i = 0; i < this.files[index].getDurationSecs(); i++) {
                  System.out.println("la la la, pum pum");
                  try {
                      Thread.sleep(1000);
                  } catch (InterruptedException ie) {
                      System.out.println("Playback interrupted: " + ie.getMessage());
                  }
              }
              currentTrack = index;
          }
    selected: false
    status: Unchecked
  - offset: 547
    length: 9
    placeholder_text: type here
    dependency:
      lesson: Pratical_Worksheet_12
      task: Export_Import_Serializable
      file: src/player/PPlayer.java
      placeholder: 2
      is_visible: false
    initial_state:
      length: 9
      offset: 547
    initialized_from_dependency: false
    possible_answer: |-
      /**
           * {@inheritDoc}
           */
          public String list() {
              String resp = "> LIST";
              int counter = 0;
              for (int i = 0; i < this.files.length; i++) {
                  if (this.files[i] != null) {
                      try {
                          this.validateAudioFile(this.files[i]);
                          counter++;
                          resp += (counter < 9 ? "0" : "") + counter + this.files[i].getName() + "\t\t"
                                  + this.files[i].getDurationSecs() + " secs";
                      } catch (InvalidFileException ife) {
                      }
                  }
              }
              if (counter == 0) {
                  resp += "There are no audio files";
              }
              return resp;
          }


          /**
           * {@inheritDoc}
           */
          public void shufflePlay() {
              Arrays.sort(this.files, this.comparatorStrategy);
          }
    selected: false
    status: Unchecked
  - offset: 562
    length: 9
    placeholder_text: type here
    dependency:
      lesson: Pratical_Worksheet_12
      task: Export_Import_Serializable
      file: src/player/PPlayer.java
      placeholder: 3
      is_visible: false
    initial_state:
      length: 9
      offset: 562
    initialized_from_dependency: false
    possible_answer: |-
      /**
           * {@inheritDoc}
           */
          public void backup(String path) throws IOException {

              // save the object to file
              FileOutputStream fos = null;
              ObjectOutputStream out = null;

              fos = new FileOutputStream(path);
              out = new ObjectOutputStream(fos);
              out.writeObject(this.files);
              out.close();

          }

          /**
           * {@inheritDoc}
           */
          public void recover(String path) throws IOException, ClassNotFoundException {
              // read the object from file
              // save the object to file
              FileInputStream fis = null;
              ObjectInputStream in = null;
              fis = new FileInputStream(path);
              in = new ObjectInputStream(fis);
              IFile[] restoredFiles = (IFile[]) in.readObject();
              System.out.println(restoredFiles.length);
              for (IFile f : restoredFiles) {
                  System.out.println(f);
              }
              in.close();
              this.files = restoredFiles;

          }
    selected: false
    status: Unchecked
  - offset: 577
    length: 61
    placeholder_text: |-
      ToDo:
      - impemente IPPodJson contract (use JSONSimple library)
    initial_state:
      length: 61
      offset: 577
    initialized_from_dependency: false
    possible_answer: |-
      /**
           * {@inheritDoc}
           */
          @Override
          public void backupJSON(String path) throws IOException {
              JSONArray arr = new JSONArray();
              for (IFile f : this.files) {
                  if (f != null) {
                      JSONObject obj = new JSONObject();
                      obj.put("name", f.getName());
                      obj.put("duration", f.getDurationSecs());
                      obj.put("size", f.getSizeKB());
                      obj.put("extension", f.getExtension());
                      arr.add(obj);
                  }
              }
              FileWriter out = new FileWriter(path);
              String ar = arr.toJSONString();
              out.write(arr.toJSONString());
              out.flush();
          }

          /**
           * {@inheritDoc}
           */
          @Override
          public void recoverJSON(String path) throws IOException, ClassNotFoundException {

              Object obj = JSONValue.parse(new FileReader(path));
              if (obj instanceof JSONArray) {
                  JSONArray jarr = (JSONArray) obj;
                  int size = jarr.size();
                  IFile[] files = new IFile[20];
                  for (int i = 0; i < size; i++) {
                      if (jarr.get(i) instanceof JSONObject) {
                          JSONObject temp = (JSONObject) jarr.get(i);
                          files[i] = new File((String) temp.get("name"), (String) temp.get("extension"), Math.toIntExact((long) temp.get("size")), Math.toIntExact((long) temp.get("duration")));
                      }
                  }
                  this.files = files;
              }
          }
    selected: false
    status: Unchecked
  text: |
    package player;

    import org.json.simple.JSONArray;
    import org.json.simple.JSONObject;
    import org.json.simple.JSONValue;
    import player.comparators.AscendingDurationComparator;
    import player.exceptions.InvalidFileException;
    import player.exceptions.InvalidPlayerStateException;

    import java.io.*;
    import java.util.Arrays;
    import java.util.Comparator;

    public class PPlayer implements PPod, IPPodSerializable, IPPodJson {
        /**
         * Number of global failures while adding files
         */
        public static int globalFailures = 0;


    type here


        type here

        type here

        ToDo:
    - impemente IPPodJson contract (use JSONSimple library)
    }
  learner_created: false
- name: src/player/File.java
  visible: true
  placeholders:
  - offset: 515
    length: 9
    placeholder_text: type here
    dependency:
      lesson: Pratical_Worksheet_12
      task: Export_Import_Serializable
      file: src/player/File.java
      placeholder: 1
      is_visible: false
    initial_state:
      length: 9
      offset: 515
    initialized_from_dependency: false
    possible_answer: |-
      //Instance Variables
          private String name;
          private String extension;
          private int sizeKB;
          private int durationSecs;

          /**
           * Creates an instance of <code>File</code>
           *
           * @param name         The {@link File#name file name}
           * @param extension    The {@link File#extension file extension}
           * @param sizeKB       The {@link File#sizeKB file size} (in KB)
           * @param durationSecs The {@link File#durationSecs file duration} (in seconds)
           */
          public File(String name, String extension, int sizeKB, int durationSecs) {
              this.name = name;
              this.extension = extension;
              this.sizeKB = sizeKB;
              this.durationSecs = durationSecs;
          }

          /**
           * {@inheritDoc}
           */
          public String getName() {
              return name;
          }

          /**
           * {@inheritDoc}
           */
          public String getExtension() {
              return extension;
          }

          /**
           * {@inheritDoc}
           */
          public int getSizeKB() {
              return sizeKB;
          }

          /**
           * {@inheritDoc}
           */
          public int getDurationSecs() {
              return durationSecs;
          }

          /**
           * {@inheritDoc}
           */
          @Override
          public String toString() {
              String s = "== File ==\nName: " + name + "\n";
              s += "Extension: " + extension + "\n";
              s += "Duration: " + durationSecs + "\n";
              s += "Size: " + sizeKB;
              return s;
          }
    selected: false
    status: Unchecked
  - offset: 529
    length: 9
    placeholder_text: type here
    dependency:
      lesson: Pratical_Worksheet_12
      task: Export_Import_Serializable
      file: src/player/File.java
      placeholder: 2
      is_visible: false
    initial_state:
      length: 9
      offset: 529
    initialized_from_dependency: false
    possible_answer: |2-
       /**
           * {@inheritDoc}
           */
          @Override
          public boolean equals(Object o) {
              if (this == o) return true;
              if (o == null || getClass() != o.getClass()) return false;
              File file = (File) o;
              return sizeKB == file.sizeKB &&
                      durationSecs == file.durationSecs &&
                      name.equals(file.name) &&
                      extension.equals(file.extension);
          }
    selected: false
    status: Unchecked
  text: |
    package player;

    import java.io.Serializable;

    /**
     * <h1> Classe utilizada para armazenar a informação relativa a um ficheiro {@link File} </h1>
     *
     * <h2>
     * ESTG - Escola Superior de Tecnologia e Gestão <br>
     * IPP - Instituto Politécnico do Porto <br>
     * PP - Paradigmas da Programação <br>
     * </h2>
     *
     * <h3>
     * LEI - Licenciatura em Engenharia Informática <br>
     * LSIRC - Licenciatura em Segurança Informática e Redes de Computadores <br>
     * </h3>
     */
    public class File implements IFile, Serializable {

        type here

       type here
    }
  learner_created: false
- name: src/player/exceptions/InvalidPlayerStateException.java
  visible: true
  placeholders:
  - offset: 482
    length: 9
    placeholder_text: type here
    dependency:
      lesson: Pratical_Worksheet_12
      task: Export_Import_Serializable
      file: src/player/exceptions/InvalidPlayerStateException.java
      placeholder: 1
      is_visible: false
    initial_state:
      length: 9
      offset: 482
    initialized_from_dependency: false
    possible_answer: |-
      /**
           * Constructs an instance of <code>InvalidPlayerStateException</code> with
           * the specified detail message.
           *
           * @param msg the detail message.
           */
          public InvalidPlayerStateException(String msg) {
              super("Player exception: " + msg);
          }
    selected: false
    status: Unchecked
  text: |-
    package player.exceptions;

    /**
     * <h1> This class implements the invalid player state exception </h1>
     *
     * <h2>
     * ESTG - Escola Superior de Tecnologia e Gestão <br>
     * IPP - Instituto Politécnico do Porto <br>
     * PP - Paradigmas da Programação <br>
     * </h2>
     *
     * <h3>
     * LEI - Licenciatura em Engenharia Informática <br>
     * LSIRC - Licenciatura em Segurança Informática e Redes de Computadores <br>
     * </h3>
     */
    public class InvalidPlayerStateException extends Exception {

        type here


    }
  learner_created: false
- name: src/Main.java
  visible: true
  placeholders:
  - offset: 501
    length: 37
    placeholder_text: //Add Custom tests to the application
    dependency:
      lesson: Pratical_Worksheet_12
      task: Export_Import_Serializable
      file: src/Main.java
      placeholder: 1
      is_visible: false
    initial_state:
      length: 37
      offset: 501
    initialized_from_dependency: false
    possible_answer: |2-
        PPlayer p = new PPlayer();
              File f3 = new File("A", "mp3", 2, 1);
              try {
                  p.addFile(f1);

                  p.addFile(f2);
                  p.addFile(f3);
                  p.backupJSON("temp.json");
                  PPlayer pp = new PPlayer();
                  pp.recoverJSON("temp.json");
                  int i = 0;
                  while (i < 3) {
                      System.out.println(p.deleteFile(0).equals(pp.deleteFile(0)));
                      i++;
                  }
              } catch (InvalidPlayerStateException e) {
                  e.printStackTrace();
              } catch (InvalidFileException | IOException | ClassNotFoundException e) {
                  e.printStackTrace();
              }
    selected: false
    status: Unchecked
  text: |-
    import player.File;
    import player.PPlayer;
    import player.exceptions.InvalidFileException;
    import player.exceptions.InvalidPlayerStateException;

    import java.io.IOException;

    public class Main {
        public static void main(String[] args) {
            File f1 = new File("Legendary Tiger Man - Big Black Boat", "mp3", 3400, 5);
            File f2 = new File("Legendary Tiger Man - Big Black Boat", "mp4", 5000, 15);
            System.out.println(f1.toString());
            System.out.println(f2.toString());

          //Add Custom tests to the application
        }
    }
  learner_created: false
- name: src/player/IPPodSerializable.java
  visible: true
  text: |
    package player;

    import java.io.IOException;

    public interface IPPodSerializable {

        /**
         * Creates a backup file with the stored files
         *
         * @param path The path to create the file
         * @throws IOException Exception thrown when it is not possible to use the file
         */
        public void backup(String path) throws IOException;

        /**
         * Recovers data from an existing file
         *
         * @param path The path to the backup file
         * @throws IOException            Exception thrown when it is not possible to use the file
         * @throws ClassNotFoundException Exception thrown when could not convert to defined object
         */
        public void recover(String path) throws IOException, ClassNotFoundException;
    }
  learner_created: false
- name: src/player/IPPodJson.java
  visible: true
  text: |
    package player;

    import java.io.IOException;

    public interface IPPodJson {

        /**
         * Creates a backup json file with the stored files
         *
         * @param path The path to create the file
         * @throws IOException Exception thrown when it is not possible to use the file
         */
        public void backupJSON(String path) throws IOException;

        /**
         * Recovers data from an existing json file
         *
         * @param path The path to the backup file
         * @throws IOException            Exception thrown when it is not possible to use the file
         * @throws ClassNotFoundException Exception thrown when could not convert to defined object
         */
        public void recoverJSON(String path) throws IOException, ClassNotFoundException;

    }
  learner_created: false
status: Unchecked
record: -1
